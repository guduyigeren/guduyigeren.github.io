1.当多个线程访问同一份数据的时候很容易出现线程安全的问题。
2.为了让多个操作在同一个时间段内只能有一个线程进行，其它线程要等到该线程完成才可以继续执行

- 解决方法：
1. 当发生以上情况时，Java给我们提供了同步代码块
```
synchronized(obj){
    //obj表示同步监视器，是同一个同步对象
}
```
下面是一个用同步代码块实现的银行取钱经典例子。

```
//创建账户类
public class ZhangHu {
	private String name;
	private int number;
	public ZhangHu(String name,int number){
		this.name = name;
		this.number = number;
	}
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getNumber() {
		return number;
	}
	public void setNumber(int number) {
		this.number = number;
	}
}
```

```
//创建取钱类
public class QuThread implements Runnable{
	private ZhangHu zhanghu;
	private int money;
	public QuThread(ZhangHu zhanghu, int money){
		this.zhanghu = zhanghu;
		this.money = money;
	}
	public void run() {
		//同步代码块   (锁)
		synchronized (zhanghu) {
			if(zhanghu.getNumber()>=money){
				//计算账户余额
				zhanghu.setNumber(zhanghu.getNumber()-money);
				System.out.println("取款成功，取走"+money+"元，余额是"+zhanghu.getNumber());
			}else{
				System.out.println("余额不足，当前余额是"+zhanghu.getNumber()+"差"+(money-zhanghu.getNumber()));
				
			}
		}
	}
	public int getNumber() {
		return money;
	}
	public void setNumber(int number) {
		this.money = number;
	}

}
```

```
//主方法
public class YingHang {

	public static void main(String[] args) {
	    //创建账户小明金额400
		ZhangHu zhanghu = new ZhangHu("小明",4000);
		//银行卡取钱的线程
		QuThread ka = new QuThread(zhanghu,3000);
		//存折取钱的线程
		QuThread zhe = new QuThread(zhanghu,2000);
		//开启银行卡的线程
		new Thread(ka).start();
		//开启存折的线程
		new Thread(zhe).start();
	}

}

```
- 同步的前提
    
    1.必须是多个线程使用同一个锁

    2.必须保证同步中只能有一个线程在运行
    

- 同步代码块的好处

    好处：解决了多线程的安全问题
    
    弊端：多个线程需要判断锁，较为消耗资源

